## 1. Най-дълъг общ префикс :memo:

### Условие

Създайте публичен клас `PrefixExtractor` с метод

```java
public static String getLongestCommonPrefix(String[] words)
```

който по даден масив от низове `words` връща най-дългия общ префикс на думите в масива. Ако думите нямат общ префикс, масивът е празен или `null`, методът връща празен низ. В контекста на тази задача, приемаме, че думата представлява произволен низ от символи.

### Примери

| Извикване                                                          | Резултат |
| :----------------------------------------------------------------- | :------- |
| `getLongestCommonPrefix(new String[]{"flower", "flow", "flight"})` | `"fl"`   |
| `getLongestCommonPrefix(new String[]{"dog", "racecar", "car"})`    | `""`     |
| `getLongestCommonPrefix(new String[]{"cat"})`                      | `"cat"`  |

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса.

## 2. Туристически забележителности :statue_of_liberty:

### Условие

Като туристи, посещаващи нова за нас дестинация, имаме сложната задача, как за ограниченото ни време там, да посетим най-яките забележителности. Предварително сме проучили и сме съставили списък на забележителностите и техния рейтинг, но те са разпръснати из целия град, разстоянията помежду им са значителни и май ще можем да посетим само две от тях.

Създайте публичен клас `TourGuide` с метод

```java
public static int getBestSightseeingPairScore(int[] places)
```

който получава като аргумент масив от цели числа `places` и връща оценката на най-добрата двойка забележителности, която се изчислява по следния начин: `places[i]` е рейтингът на `i`-тата забележителност, а две забележителности `i` и `j` се намират на разстояние `j` - `i` една от друга. Оценката на двойката забележителности (`i` < `j`) се смята като `places[i] + places[j] + i - j`, т.е. сумата от рейтингите на двете забележителности, минус разстоянието помежду им.

### Примери

| Извикване                                               | Резултат |
| :------------------------------------------------------ | :------- |
| `getBestSightseeingPairScore(new int[]{8, 1, 5, 2, 6})` | `11`     |
| `getBestSightseeingPairScore(new int[]{1, 2})`          | `2`      |

В първия пример по-горе, `i = 0, j = 2, places[i] + places[j] + i - j = 8 + 5 + 0 - 2 = 11`.

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса.

## Data center :computer:

### Условие

Разполагаме с карта на data center, представена чрез матрица `m * n` от цели числа, съдържаща само нули и единици, в която 1 в дадена клетка означава, че в нея има сървър, а 0 означава, че там няма сървър. Казваме, че два сървъра си комуникират, ако те се намират на един и същи ред или в една и съща колона на матрицата.

Създайте публичен клас `DataCenter` с метод

```java
public static int getCommunicatingServersCount(int[][] map)
```

който получава като аргумент коректна матрица от този вид и връща броя на сървърите в дадения data center, които си комуникират с произволен друг сървър.

### Примери

<img src="https://github.com/fmi/java-course/blob/master/01-intro-to-java/lecture/images/communicating-servers.png" alt="Communicating servers">

| Извикване                                                                                          | Резултат |
| :------------------------------------------------------------------------------------------------- | :------- |
| `getCommunicatingServersCount(new int[][]{ {1, 0}, {0, 1} })`                                        | `0`      |
| `getCommunicatingServersCount(new int[][]{ {1, 0}, {1, 1} })`                                        | `3`      |
| `getCommunicatingServersCount(new int[][]{ {1, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 0, 1} }` | `4`      |

### :warning: Забележки

- Използването на структури от данни, различни от масив, **не е позволено**. Задачата трябва да се реши с помощта на знанията от първата лекция от курса.
